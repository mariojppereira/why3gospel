(**************************************************************************)
(*                                                                        *)
(*  GOSPEL -- A Specification Language for OCaml                          *)
(*                                                                        *)
(*  Copyright (c) 2018- The VOCaL Project                                 *)
(*                                                                        *)
(*  This software is free software, distributed under the MIT license     *)
(*  (as described in file LICENSE enclosed).                              *)
(**************************************************************************)

(** This module mirrors the GOSPEL standard library.
    It is used in the Why3 modules built by the GOSPEL plug-in for Why3. *)

module Stdlib

  use export int.Int
  use export int.MinMax
  use export option.Option
  use export ocaml.Exceptions
  use export ocaml.Sys
  use export ocaml.Pervasives
  use export list.List
  use export mach.array.Array63Permut

  type integer = int

  use int.ComputerDivision    (* FIXME? Euclidean division instead *)
  function (/) (x y: int) : int = div x y

  use mach.int.Int63
  function integer_of_int (x: int63) : int = to_int x

  (* TODO: many things are missing.
     See file ../gospel/stdlib/gospelstdlib.mli *)

  use int.Int
  use mach.int.Int63

  predicate is_pre_order (cmp: 'a -> 'a -> int63) =
    (forall x. cmp x x = 0) /\
    (forall x y. cmp x y = 0 <-> cmp y x = 0) /\
    (forall x y. cmp x y < 0 <-> cmp y x > 0) /\
    (forall x y z.
      (cmp x y = 0 -> cmp y z = 0 -> cmp x z = 0) /\
      (cmp x y = 0 -> cmp y z < 0 -> cmp x z < 0) /\
      (cmp x y < 0 -> cmp y z = 0 -> cmp x z < 0) /\
      (cmp x y < 0 -> cmp y z < 0 -> cmp x z < 0))

  use import seq.Seq as S
  type seq 'a = S.seq 'a
  function length (s: seq 'a): integer = S.length s

  function ([]) (s: seq 'a) (i:integer): 'a = S.([]) s i

  predicate (==) (s1 s2: seq 'a) =
    length s1 = length s2 &&
    forall i. 0 <= i < length s1 -> s1[i] = s2[i]

(*@ function ([_.._]) (s: 'a seq) (i1: integer) (i2: integer): 'a seq *)
(*@ function ([_..]) (s: 'a seq) (i: integer): 'a seq *)
(*@ function ([.._]) (s: 'a seq) (i: integer): 'a seq *)

  constant empty: seq 'a = S.empty

(*@ function (++) (s1: 'a seq) (s2: 'a seq): 'a seq *)

  use seq.OfList

  function seq_of_list (l: list 'a) : seq 'a = of_list l

  use import mach.peano.Peano as P
  function int_of_peano (t: P.t) : int = t

  use import set.Fset as FS
  type set 'a = fset 'a

end

module Comparable

  use int.Int
  use mach.int.Int63
  use Stdlib

  type t

  function cmp: t -> t -> int63
  axiom is_pre_order: is_pre_order cmp

  val compare (x y: t) : int63
    ensures { result = cmp x y }

  predicate le (x y: t) = cmp x y <= 0

end

module Seq

  use export seq.Seq
  use export seq.FoldLeft
  use export seq.FoldRight
  use export seq.Sorted

end

module Bag

  use export bag.Bag

end

module Set

  use import set.Fset as FS

  type set 'a = FS.fset 'a
  predicate mem (x: 'a) (s: set 'a) = FS.mem x s

  constant empty: set 'a = FS.empty

  function singleton (x: 'a) : set 'a = FS.singleton x

  function union (s1 s2: set 'a) : set 'a = FS.union s1 s2

  use import set.FsetSum as FSum

  use Stdlib
  function sum (f: 'a -> integer) (x: set 'a) : integer = FSum.sum x f

end

module Map

  use export map.Map

end

module Peano

  use export mach.peano.Peano

end

module SeqPerm
  use export seq.Permut
end